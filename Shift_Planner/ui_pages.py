# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
import datetime as dt
from datetime import date as dt_date, timedelta
from typing import List, Optional, Tuple, Dict, Any
import inspect

# ---------- Imports (robust to package/non-package layout) ----------
try:
    from .constants import DAYS, SHIFT_TIMES, ALL_SHIFTS, DEFAULT_ROLES
except Exception:  # pragma: no cover
    from constants import DAYS, SHIFT_TIMES, ALL_SHIFTS, DEFAULT_ROLES  # type: ignore

# Core DB API (guaranteed)
try:
    try:
        from .db import (
            get_all_companies, get_company, update_company, create_company,
            get_employees, add_employee, update_employee, delete_employee,
        )
    except Exception:  # pragma: no cover
        from db import (  # type: ignore
            get_all_companies, get_company, update_company, create_company,
            get_employees, add_employee, update_employee, delete_employee,
        )
    _DB_OK = True
except Exception:
    _DB_OK = False
    get_all_companies = get_company = update_company = create_company = None  # type: ignore
    get_employees = add_employee = update_employee = delete_employee = None  # type: ignore

# Optional DB helpers (may not exist or may have different signatures)
def _maybe_get(name: str):
    for modname in (".db", "db"):
        try:
            if modname == ".db":
                from . import db as _db  # type: ignore
            else:
                import db as _db  # type: ignore
            return getattr(_db, name, None)
        except Exception:
            continue
    return None

get_schedule_range = _maybe_get("get_schedule_range")
bulk_save_week_schedule = _maybe_get("bulk_save_week_schedule")
get_employee_id_by_name = _maybe_get("get_employee_id_by_name")
create_swap_request = _maybe_get("create_swap_request")
list_swap_requests = _maybe_get("list_swap_requests")
update_swap_status = _maybe_get("update_swap_status")
apply_approved_swap = _maybe_get("apply_approved_swap")

# --- Optional import: validator / auto-fix ---
try:
    try:
        from .scheduler import check_violations
        try:
            from .scheduler import auto_fix_schedule as _auto_fix_schedule
        except Exception:
            _auto_fix_schedule = None
    except Exception:  # pragma: no cover
        from scheduler import check_violations  # type: ignore
        try:
            from scheduler import auto_fix_schedule as _auto_fix_schedule  # type: ignore
        except Exception:
            _auto_fix_schedule = None
except Exception:  # ultimate fallback
    def check_violations(df, rules, work_model="5ŒÆŒºŒµœÅŒø"):
        return pd.DataFrame()
    _auto_fix_schedule = None

# ===== Local safe fallback to replace removed DEFAULT_RULES =====
# (You removed DEFAULT_RULES previously; keep UI resilient)
DEFAULT_RULES_FALLBACK = {
    "max_daily_hours_5days": 8,
    "max_daily_hours_6days": 9,
    "max_daily_hours_7days": 9,
    "max_daily_overtime": 3,
    "min_daily_rest": 11,
    "weekly_hours_5days": 40,
    "weekly_hours_6days": 48,
    "weekly_hours_7days": 56,
    "monthly_hours": 160,
    "max_consecutive_days": 6,
}

# ======================== THEME & GLOBAL STYLE ========================
def _apply_global_style():
    """Theme-aware CSS: respects Streamlit theme tokens (no hardcoded colors)."""
    if st.session_state.get("_styled_once"):
        return
    st.markdown(
        """
        <style>
        /* Tighten vertical rhythm */
        .block-container { padding-top: 1.2rem; padding-bottom: 2.4rem; }
        section[data-testid="stSidebar"] .block-container { padding-top: 0.8rem; }

        /* Cards/expanders polish */
        .stMetric { border-radius: 16px; padding: 0.4rem 0.6rem; }
        div[data-testid="stExpander"] > details { border-radius: 14px; }
        div[data-testid="stExpander"] summary { font-weight: 600; }

        /* Data editor header wrap + denser rows */
        div[data-testid="stDataFrame"] .st-emotion-cache-1yycgf0 { white-space: normal !important; }
        div[data-testid="stDataFrame"] .row_heading { font-weight: 600; }
        div[data-testid="stDataFrame"] .blank { color: var(--text-color); }

        /* Primary buttons a bit rounded */
        .stButton>button, .stDownloadButton>button {
          border-radius: 12px;
          padding: 0.45rem 0.9rem;
          font-weight: 600;
        }
        /* Soft badge button */
        .btn-soft>button {
          background: color-mix(in srgb, var(--primary-color) 16%, transparent);
          color: var(--primary-color);
          border: 1px solid color-mix(in srgb, var(--primary-color) 30%, transparent);
        }

        /* Use theme variables so dark/light works */
        :root, [data-theme="dark"] {
          --kpi-bg: color-mix(in srgb, var(--background-color) 85%, var(--primary-color) 15%);
        }
        .kpi-card { background: var(--kpi-bg); border-radius: 16px; padding: .8rem; }
        </style>
        """,
        unsafe_allow_html=True,
    )
    st.session_state["_styled_once"] = True

# ======================== CACHING HELPERS ========================
# Cache lightweight reads; callers can still force-refresh with st.rerun().
if hasattr(st, "cache_data"):
    cache_data = st.cache_data
else:  # Streamlit < 1.18 fallback
    def cache_data(func=None, **_):
        return func

@cache_data(show_spinner=False)
def _cached_companies():
    return get_all_companies() if callable(get_all_companies) else []

@cache_data(show_spinner=False)
def _cached_employees(company_id: int):
    return get_employees(company_id) if callable(get_employees) else []

@cache_data(show_spinner=False)
def _cached_schedule(company_id: int, start_iso: str, end_iso: str):
    if callable(get_schedule_range):
        return get_schedule_range(company_id, start_iso, end_iso) or []
    return []

# ======================== PAGES ========================

def page_select_company():
    """Company selection page."""
    st.subheader("üè¢ ŒïœÄŒπŒªŒøŒ≥ŒÆ ŒïœÄŒπœáŒµŒØœÅŒ∑œÉŒ∑œÇ")

    companies = get_all_companies()() if False else (get_all_companies() if callable(get_all_companies) else [])
    if not companies:
        if callable(create_company) and callable(get_all_companies):
            st.info("ŒîŒµŒΩ œÖœÄŒ¨œÅœáŒøœÖŒΩ ŒµœÑŒ±ŒπœÅŒµŒØŒµœÇ. ŒîŒ∑ŒºŒπŒøœçœÅŒ≥Œ∑œÉŒ± ŒºŒπŒ± default.")
            create_company("Default Business")
            companies = get_all_companies() or []
        else:
            st.info("ŒõŒµŒπœÑŒøœÖœÅŒ≥ŒØŒ± ŒµœÄŒØŒ¥ŒµŒπŒæŒ∑œÇ: Œ∑ ŒíŒî Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒ∑.")
            companies = [{"id": -1, "name": "Demo Business"}]

    options = {f"{c.get('name','?')} (ID:{c.get('id','?')})": c.get('id') for c in companies}
    if not options:
        st.error("ŒîŒµŒΩ Œ≤œÅŒ≠Œ∏Œ∑Œ∫Œ±ŒΩ ŒµœÑŒ±ŒπœÅŒµŒØŒµœÇ (Œ¨Œ¥ŒµŒπŒ± ŒªŒØœÉœÑŒ±).")
        return

    selected_label = st.selectbox("ŒïœÄŒπŒªŒøŒ≥ŒÆ", list(options.keys()))
    if st.button("‚úÖ ŒÜŒΩŒøŒπŒ≥ŒºŒ±") and selected_label in options:
        company_id = options[selected_label]
        st.session_state.company = get_company(company_id) if callable(get_company) else {"id": -1, "name": "Demo"}
        st.session_state.company.setdefault("active_shifts", ALL_SHIFTS.copy())
        st.session_state.company.setdefault("roles", DEFAULT_ROLES.copy())
        st.session_state.company.setdefault("rules", DEFAULT_RULES_FALLBACK.copy())
        st.session_state.company.setdefault("role_settings", {})
        st.session_state.company.setdefault("work_model", "5ŒÆŒºŒµœÅŒø")
        st.session_state.employees = get_employees(company_id) if callable(get_employees) else []
        st.rerun()

    with st.expander("ŒîŒµŒΩ Œ≤ŒªŒ≠œÄŒµŒπœÇ ŒµœÑŒ±ŒπœÅŒµŒØŒ±;"):
        if st.text_input("ŒåŒΩŒøŒºŒ± ŒΩŒ≠Œ±œÇ ŒµœÑŒ±ŒπœÅŒµŒØŒ±œÇ", key="new_co_name"):
            if st.button("‚ûï ŒîŒ∑ŒºŒπŒøœÖœÅŒ≥ŒØŒ±"):
                if callable(create_company):
                    create_company(st.session_state["new_co_name"].strip())
                    st.success("Œó ŒµœÑŒ±ŒπœÅŒµŒØŒ± Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥ŒÆŒ∏Œ∑Œ∫Œµ.")
                    st.rerun()
                else:
                    st.info("ŒõŒµŒπœÑŒøœÖœÅŒ≥ŒØŒ± ŒµœÄŒØŒ¥ŒµŒπŒæŒ∑œÇ: Œ∑ ŒíŒî Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒ∑.")



def page_business():
    """Company settings page (polished)."""
    _apply_global_style()
    back_to_company_selection("back_business")
    st.subheader("‚öôÔ∏è Œ°œÖŒ∏ŒºŒØœÉŒµŒπœÇ ŒïœÄŒπœáŒµŒØœÅŒ∑œÉŒ∑œÇ")

    if "company" not in st.session_state or not st.session_state.get("company", {}):
        st.warning("ŒîŒµŒΩ Œ≠œáŒµŒπ ŒµœÄŒπŒªŒµŒ≥ŒµŒØ ŒµœÄŒπœáŒµŒØœÅŒ∑œÉŒ∑.")
        return

    company = st.session_state.company
    company.setdefault("active_shifts", ALL_SHIFTS.copy())
    company.setdefault("roles", DEFAULT_ROLES.copy())
    company.setdefault("rules", DEFAULT_RULES_FALLBACK.copy())
    company.setdefault("role_settings", {})
    company.setdefault("work_model", "5ŒÆŒºŒµœÅŒø")

    with st.container():
        st.subheader("ŒíŒ±œÉŒπŒ∫Œ¨")
        col1, col2 = st.columns([2, 1])
        with col1:
            company["name"] = st.text_input("ŒåŒΩŒøŒºŒ± ŒµœÄŒπœáŒµŒØœÅŒ∑œÉŒ∑œÇ", company.get("name", ""))
        with col2:
            options = ["5ŒÆŒºŒµœÅŒø", "6ŒÆŒºŒµœÅŒø", "7ŒÆŒºŒµœÅŒø"]
            current = company.get("work_model", "5ŒÆŒºŒµœÅŒø")
            idx = options.index(current) if current in options else 0
            company["work_model"] = st.selectbox("ŒúŒøŒΩœÑŒ≠ŒªŒø ŒµœÅŒ≥Œ±œÉŒØŒ±œÇ", options, index=idx, help="ŒßœÅŒ∑œÉŒπŒºŒøœÄŒøŒπŒµŒØœÑŒ±Œπ œÉœÑŒøœÖœÇ ŒµŒªŒ≠Œ≥œáŒøœÖœÇ œÉœÖŒºŒºœåœÅœÜœâœÉŒ∑œÇ.")

    with st.expander("üïí ŒíŒ¨œÅŒ¥ŒπŒµœÇ", expanded=False):
        new_shift = st.text_input("Œ†œÅŒøœÉŒ∏ŒÆŒ∫Œ∑ ŒΩŒ≠Œ±œÇ Œ≤Œ¨œÅŒ¥ŒπŒ±œÇ")
        c1, c2 = st.columns(2)
        if c1.button("‚ûï Œ†œÅŒøœÉŒ∏ŒÆŒ∫Œ∑"):
            if new_shift and new_shift not in company["active_shifts"]:
                company["active_shifts"].append(new_shift)
                st.toast("Œ†œÅŒøœÉœÑŒ≠Œ∏Œ∑Œ∫Œµ Œ≤Œ¨œÅŒ¥ŒπŒ±.")
        if c2.button("‚Ü©Ô∏è ŒïœÄŒ±ŒΩŒ±œÜŒøœÅŒ¨ œÄœÅŒøŒµœÄŒπŒªŒøŒ≥œéŒΩ"):
            company["active_shifts"] = ALL_SHIFTS.copy()
        st.multiselect("ŒïŒΩŒµœÅŒ≥Œ≠œÇ Œ≤Œ¨œÅŒ¥ŒπŒµœÇ", company["active_shifts"], default=company["active_shifts"], disabled=True)

    with st.expander("üëî Œ°œåŒªŒøŒπ & Œ°œÖŒ∏ŒºŒØœÉŒµŒπœÇ", expanded=True):
        new_role = st.text_input("ŒùŒ≠ŒøœÇ œÅœåŒªŒøœÇ")
        cols = st.columns([0.28, 0.28, 0.44])
        if cols[0].button("‚ûï Œ†œÅŒøœÉŒ∏ŒÆŒ∫Œ∑ Œ°œåŒªŒøœÖ", use_container_width=True):
            if new_role and new_role not in company["roles"]:
                company["roles"].append(new_role)
                st.toast("Œ†œÅŒøœÉœÑŒ≠Œ∏Œ∑Œ∫Œµ œÅœåŒªŒøœÇ.")
        cols[1].button("üì¶ Œ†œÅŒøŒµœÄŒπŒªŒµŒ≥ŒºŒ≠ŒΩŒøŒπ œÅœåŒªŒøŒπ", help="ŒîŒµŒΩ œÑœÅŒøœÄŒøœÄŒøŒπŒµŒØ œÑŒøœÖœÇ œÑœÅŒ≠œáŒøŒΩœÑŒµœÇ œÅœåŒªŒøœÖœÇ ‚Äî ŒºœåŒΩŒø ŒµŒΩŒ∑ŒºŒ≠œÅœâœÉŒ∑.", use_container_width=True)
        cols[2].empty()

        company.setdefault("role_settings", {})
        for r in company.get("roles", []):
            rs = company["role_settings"].setdefault(r, {})
            rs["priority"]        = int(rs.get("priority", 5))
            rs["min_per_shift"]   = int(rs.get("min_per_shift", 1))
            rs["max_per_shift"]   = int(rs.get("max_per_shift", 5))
            rs["max_hours_week"]  = int(rs.get("max_hours_week", 40))
            rs["cost"]            = float(rs.get("cost", 0.0))
            rs.setdefault("preferred_shifts", [])

            st.markdown(f"**{r}**")
            col = st.columns(3)
            rs["priority"]       = col[0].slider("Œ†œÅŒøœÑŒµœÅ.", 1, 10, rs["priority"], key=f"prio_{r}")
            rs["min_per_shift"]  = col[1].number_input("Min/shift", 0, 10, rs["min_per_shift"], key=f"min_{r}")
            rs["max_per_shift"]  = col[2].number_input("Max/shift", 1, 10, rs["max_per_shift"], key=f"max_{r}")
            rs["preferred_shifts"] = st.multiselect(
                "Œ†œÅŒøœÑŒπŒºœéŒºŒµŒΩŒµœÇ Œ≤Œ¨œÅŒ¥ŒπŒµœÇ",
                company.get("active_shifts", []),
                default=rs.get("preferred_shifts", []),
                key=f"pref_{r}"
            )

    with st.expander("‚öñÔ∏è ŒöŒ±ŒΩœåŒΩŒµœÇ", expanded=False):
        rules = company.get("rules", {})
        rule_defs = {
            "max_daily_hours_5days": (6, 12, rules.get("max_daily_hours_5days", 8)),
            "max_daily_hours_6days": (6, 12, rules.get("max_daily_hours_6days", 9)),
            "max_daily_hours_7days": (6, 12, rules.get("max_daily_hours_7days", 9)),
            "max_daily_overtime":    (0, 6,  rules.get("max_daily_overtime", 3)),
            "min_daily_rest":        (8, 24, rules.get("min_daily_rest", 11)),
            "weekly_hours_5days":    (30, 50, rules.get("weekly_hours_5days", 40)),
            "weekly_hours_6days":    (30, 60, rules.get("weekly_hours_6days", 48)),
            "weekly_hours_7days":    (35, 70, rules.get("weekly_hours_7days", 56)),
            "monthly_hours":         (100, 300, rules.get("monthly_hours", 160)),
            "max_consecutive_days":  (3, 10, rules.get("max_consecutive_days", 6)),
        }
        for k, (mn, mx, dv) in rule_defs.items():
            rules[k] = st.number_input(k, mn, mx, dv)
        company["rules"] = rules

    st.divider()
    if st.button("üíæ ŒëœÄŒøŒ∏ŒÆŒ∫ŒµœÖœÉŒ∑ Œ°œÖŒ∏ŒºŒØœÉŒµœâŒΩ", type="primary"):
        try:
            if _DB_OK and callable(update_company):
                update_company(company["id"], company)
                st.success("ŒëœÄŒøŒ∏Œ∑Œ∫ŒµœçœÑŒ∑Œ∫Œµ.")
            else:
                st.info("ŒõŒµŒπœÑŒøœÖœÅŒ≥ŒØŒ± ŒµœÄŒØŒ¥ŒµŒπŒæŒ∑œÇ: Œ∑ ŒíŒî Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒ∑.")
        except Exception as ex:
            st.error(f"ŒëœÄŒøœÑœÖœáŒØŒ±: {ex}")

# ------------------------- Employees ------------------------- #
def page_employees():
    _apply_global_style()
    back_to_company_selection("back_employees")
    st.subheader("üë• Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøŒπ")

    if "company" not in st.session_state:
        st.warning("ŒïœÄŒπŒªŒ≠ŒæœÑŒµ ŒµœÄŒπœáŒµŒØœÅŒ∑œÉŒ∑ œÄœÅœéœÑŒ±.")
        return

    company = st.session_state.company
    st.session_state.setdefault("employees", _cached_employees(company.get("id", -1)))

    with st.form("add_emp", clear_on_submit=True):
        st.markdown("##### ‚ûï Œ†œÅŒøœÉŒ∏ŒÆŒ∫Œ∑")
        name = st.text_input("ŒåŒΩŒøŒºŒ±")
        roles = st.multiselect("Œ°œåŒªŒøŒπ", company.get("roles", []))
        availability = st.multiselect("ŒîŒπŒ±Œ∏ŒµœÉŒπŒºœåœÑŒ∑œÑŒ±", company.get("active_shifts", []))
        submitted = st.form_submit_button("Œ†œÅŒøœÉŒ∏ŒÆŒ∫Œ∑", use_container_width=True)
    if submitted:
        _add_employee_handler(company, name, roles, availability)

    employees = st.session_state.employees
    if not employees:
        _empty_state(
            "ŒîŒµŒΩ œÖœÄŒ¨œÅœáŒøœÖŒΩ Œ±Œ∫œåŒºŒ± œÖœÄŒ¨ŒªŒªŒ∑ŒªŒøŒπ.",
            ["Œ†œÅŒøœÉŒ∏Œ≠œÉœÑŒµ œÄœÅŒøœÉœâœÄŒπŒ∫œå Œ≥ŒπŒ± ŒΩŒ± ŒæŒµŒ∫ŒπŒΩŒÆœÉŒµŒπ Œ∑ Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥ŒØŒ± œÄœÅŒøŒ≥œÅŒ¨ŒºŒºŒ±œÑŒøœÇ."],
            demo_button=True,
            on_demo=_demo_seed,
        )
        return

    for emp in employees:
        with st.expander(f"{emp['name']}"):
            c1, c2 = st.columns([0.65, 0.35])
            with c1:
                new_name = st.text_input("ŒåŒΩŒøŒºŒ±", value=emp["name"], key=f"name_{emp['id']}")
                current_roles = _employee_roles(emp)
                role_options = company.get("roles", [])
                default_roles, missing_roles = _sanitize_default(role_options, current_roles)
                new_roles = st.multiselect("Œ°œåŒªŒøŒπ", role_options, default=default_roles, key=f"roles_{emp['id']}")
                if missing_roles:
                    st.caption("‚ö†Ô∏è ŒëŒ≥ŒΩŒøŒÆŒ∏Œ∑Œ∫Œ±ŒΩ œÅœåŒªŒøŒπ: " + ", ".join(missing_roles))

                current_av = _availability_list(emp)
                shift_options = company.get("active_shifts", [])
                default_av, missing_av = _sanitize_default(shift_options, current_av)
                new_av = st.multiselect("ŒîŒπŒ±Œ∏ŒµœÉŒπŒºœåœÑŒ∑œÑŒ±", shift_options, default=default_av, key=f"av_{emp['id']}")
                if missing_av:
                    st.caption("‚ö†Ô∏è ŒëŒ≥ŒΩŒøŒÆŒ∏Œ∑Œ∫Œ±ŒΩ Œ≤Œ¨œÅŒ¥ŒπŒµœÇ: " + ", ".join(missing_av))
            with c2:
                st.write(" ")
                st.write(" ")
                if st.button("üíæ ŒëœÄŒøŒ∏ŒÆŒ∫ŒµœÖœÉŒ∑", key=f"save_{emp['id']}"):
                    _save_employee_handler(emp, new_name, new_roles, new_av, role_options, shift_options)
                if st.button("üóëÔ∏è ŒîŒπŒ±Œ≥œÅŒ±œÜŒÆ", key=f"del_{emp['id']}"):
                    st.session_state[f"confirm_del_{emp['id']}"] = True
                if st.session_state.get(f"confirm_del_{emp['id']}", False):
                    st.warning(f"Œ£ŒØŒ≥ŒøœÖœÅŒ± Œ¥ŒπŒ±Œ≥œÅŒ±œÜŒÆ œÑŒøœÖ/œÑŒ∑œÇ **{emp['name']}**;", icon="‚ö†Ô∏è")
                    cc1, cc2 = st.columns(2)
                    if cc1.button("‚ùå ŒëŒ∫œçœÅœâœÉŒ∑", key=f"cancel_del_{emp['id']}"):
                        st.session_state[f"confirm_del_{emp['id']}"] = False
                    if cc2.button("‚úÖ ŒïœÄŒπŒ≤ŒµŒ≤Œ±ŒØœâœÉŒ∑", key=f"confirm_btn_{emp['id']}"):
                        _delete_employee_handler(emp)

# ------------------------- Schedule ------------------------- #
def page_schedule():
    _apply_global_style()
    back_to_company_selection("back_schedule")
    st.subheader("üìÖ Œ†œÅœåŒ≥œÅŒ±ŒºŒºŒ±")

    st.session_state.setdefault("schedule", pd.DataFrame())
    st.session_state.setdefault("missing_staff", pd.DataFrame())
    st.session_state.setdefault("violations", pd.DataFrame())

    if "company" not in st.session_state or not st.session_state.get("company", {}).get("name"):
        st.warning("ŒîŒµŒΩ Œ≠œáŒµŒπ ŒµœÄŒπŒªŒµŒ≥ŒµŒØ ŒµœÄŒπœáŒµŒØœÅŒ∑œÉŒ∑.")
        return
    if "employees" not in st.session_state or not st.session_state.employees:
        st.warning("ŒîŒµŒΩ œÖœÄŒ¨œÅœáŒøœÖŒΩ œÖœÄŒ¨ŒªŒªŒ∑ŒªŒøŒπ. Œ†œÅŒøœÉŒ∏Œ≠œÉœÑŒµ Œ≥ŒπŒ± ŒΩŒ± Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥Œ∑Œ∏ŒµŒØ œÄœÅœåŒ≥œÅŒ±ŒºŒºŒ±.")
        return

    company = st.session_state.company
    emps = st.session_state.employees

    tabs = st.tabs(["‚öôÔ∏è ŒîŒ∑ŒºŒπŒøœÖœÅŒ≥ŒØŒ±", "üß± Visual builder", "üîÅ ŒëŒπœÑŒÆŒºŒ±œÑŒ± Œ±ŒªŒªŒ±Œ≥ŒÆœÇ"])
    with tabs[0]:
        _tab_generate(company, emps)
    with tabs[1]:
        _tab_visual_builder(company, emps)
    with tabs[2]:
        _tab_swaps(company, emps)

# ======================== Tab: Generate ========================
def _tab_generate(company: Dict[str, Any], emps: List[Dict[str, Any]]):
    col_hdr1, col_hdr2, col_hdr3, col_hdr4 = st.columns(4)
    sched = st.session_state.schedule.copy()
    if not sched.empty:
        try:
            dser = pd.to_datetime(sched["ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±"], errors="coerce").dt.date
            col_hdr1.metric("Œ£œÖŒΩŒøŒªŒπŒ∫Œ≠œÇ Œ≤Œ¨œÅŒ¥ŒπŒµœÇ", len(sched))
            col_hdr2.metric("Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøŒπ", len(emps))
            col_hdr3.metric("ŒóŒºŒ≠œÅŒµœÇ", len(set(dser)))
            col_hdr4.metric("Œ°œåŒªŒøŒπ", len(company.get("roles", [])))
        except Exception:
            pass
    else:
        col_hdr1.metric("Œ£œÖŒΩŒøŒªŒπŒ∫Œ≠œÇ Œ≤Œ¨œÅŒ¥ŒπŒµœÇ", 0)
        col_hdr2.metric("Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøŒπ", len(emps))
        col_hdr3.metric("ŒóŒºŒ≠œÅŒµœÇ", 0)
        col_hdr4.metric("Œ°œåŒªŒøŒπ", len(company.get("roles", [])))

    st.divider()
    mode = st.radio("ŒïŒºŒ≤Œ≠ŒªŒµŒπŒ±", ["üóìÔ∏è ŒïŒ≤Œ¥ŒøŒºŒ±Œ¥ŒπŒ±ŒØŒø", "üìÖ ŒúŒ∑ŒΩŒπŒ±ŒØŒø"], horizontal=True, key="mode_sched")
    days_count = 7 if mode == "üóìÔ∏è ŒïŒ≤Œ¥ŒøŒºŒ±Œ¥ŒπŒ±ŒØŒø" else 30
    start_date = st.date_input("ŒàŒΩŒ±œÅŒæŒ∑", dt_date.today(), key="start_sched")

    colb1, colb2 = st.columns([0.35, 0.35])
    with colb1:
        generate_clicked = st.button("üõ† ŒîŒ∑ŒºŒπŒøœÖœÅŒ≥ŒØŒ±", type="primary", key="btn_generate")
        if days_count == 30:
            st.caption("‚ö†Ô∏è Œó Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥ŒØŒ± Œ≥ŒπŒ± 30 Œ∑ŒºŒ≠œÅŒµœÇ Œ∏Œ± Œ±ŒΩœÑŒπŒ∫Œ±œÑŒ±œÉœÑŒÆœÉŒµŒπ œåŒªŒø œÑŒø Œ¥ŒπŒ¨œÉœÑŒ∑ŒºŒ±.")
            confirm_month = st.checkbox("ŒïœÄŒπŒ≤ŒµŒ≤Œ±ŒπœéŒΩœâ œÑŒ∑ŒΩ Œ±ŒΩœÑŒπŒ∫Œ±œÑŒ¨œÉœÑŒ±œÉŒ∑ œåŒªœâŒΩ œÑœâŒΩ 30 Œ∑ŒºŒµœÅœéŒΩ", key="confirm_month")
        else:
            confirm_month = True
    with colb2:
        refix_clicked = st.button("üßπ ŒïœÄŒ±ŒΩŒ≠ŒªŒµŒ≥œáŒøœÇ & Auto‚ÄëŒ¥ŒπœåœÅŒ∏œâœÉŒ∑", help="ŒïœÜŒ¨œÅŒºŒøœÉŒµ Œ∫Œ±ŒΩœåŒΩŒµœÇ œÉœÑŒø œÑœÅŒ≠œáŒøŒΩ œÄœÅœåŒ≥œÅŒ±ŒºŒºŒ±")

    if generate_clicked and confirm_month:
        _generate_and_save(company, emps, start_date, days_count)
    elif generate_clicked and not confirm_month:
        st.warning("ŒßœÅŒµŒπŒ¨Œ∂ŒµœÑŒ±Œπ ŒµœÄŒπŒ≤ŒµŒ≤Œ±ŒØœâœÉŒ∑ Œ≥ŒπŒ± Œ±œÄŒøŒ∏ŒÆŒ∫ŒµœÖœÉŒ∑ ŒøŒªœåŒ∫ŒªŒ∑œÅŒøœÖ ŒºŒÆŒΩŒ±.")

    if refix_clicked and not st.session_state.schedule.empty:
        _refix_current(company, emps)

# ======================== Tab: Visual Builder ========================
def _tab_visual_builder(company: Dict[str, Any], emps: List[Dict[str, Any]]):
    st.caption("Œü œÄŒØŒΩŒ±Œ∫Œ±œÇ Œ±œÜŒøœÅŒ¨ œÉœÑŒ∑ŒΩ **ŒøœÅŒ±œÑŒÆ ŒµŒ≤Œ¥ŒøŒºŒ¨Œ¥Œ±**. ŒìŒπŒ± ŒøŒªœåŒ∫ŒªŒ∑œÅŒø ŒºŒÆŒΩŒ± œáœÅŒ∑œÉŒπŒºŒøœÄŒøŒØŒ∑œÉŒµ œÑŒ∑ ŒîŒ∑ŒºŒπŒøœÖœÅŒ≥ŒØŒ±.")
    start_date = st.date_input("ŒàŒΩŒ±œÅŒæŒ∑ ŒµŒ≤Œ¥ŒøŒºŒ¨Œ¥Œ±œÇ", dt_date.today(), key="vb_start")
    dates = [start_date + timedelta(days=i) for i in range(7)]

    active_shifts = company.get("active_shifts", [])
    grid_df = _grid_from_db_week(company["id"], emps, dates[0])

    col_labels = { _column_key(d, s): f"{DAYS[d.weekday()]} {d.strftime('%d/%m')} ‚Ä¢ {s}"
                   for d in dates for s in active_shifts }

    role_choices = ["‚Äî (Œ∫Œ±ŒºŒØŒ±)", "‚Äî (œáœâœÅŒØœÇ œÅœåŒªŒø)"] + company.get("roles", [])
    colcfg = {k: st.column_config.SelectboxColumn(label=col_labels.get(k, k), options=role_choices, default="‚Äî (Œ∫Œ±ŒºŒØŒ±)")
              for k in grid_df.columns if k != "Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ"}

    edited = st.data_editor(
        grid_df,
        column_config={"Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ": st.column_config.TextColumn("Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ", disabled=True), **colcfg},
        use_container_width=True, hide_index=True, num_rows="fixed", key="vb_editor", height=360
    )

    colA, colB = st.columns([0.5, 0.5])
    with colA:
        if st.button(f"üíæ ŒëœÄŒøŒ∏ŒÆŒ∫ŒµœÖœÉŒ∑ ŒµŒ≤Œ¥ŒøŒºŒ¨Œ¥Œ±œÇ ({dates[0].isoformat()} ‚Üí {dates[-1].isoformat()})", type="primary"):
            errs = _validate_no_double_bookings(edited)
            if errs:
                for e in errs: st.error(e)
            else:
                assignments = _assignments_from_grid(edited, emps, dates[0])
                if company.get("id", 0) < 0:
                    st.info("Demo ŒµœÑŒ±ŒπœÅŒµŒØŒ±: Œ∑ Œ±œÄŒøŒ∏ŒÆŒ∫ŒµœÖœÉŒ∑ œÉœÑŒ∑ ŒíŒî ŒµŒØŒΩŒ±Œπ Œ±œÄŒµŒΩŒµœÅŒ≥ŒøœÄŒøŒπŒ∑ŒºŒ≠ŒΩŒ∑.")
                else:
                    if callable(bulk_save_week_schedule):
                        bulk_save_week_schedule(company["id"], assignments)  # 2‚Äëarg signature
                        st.success("ŒëœÄŒøŒ∏Œ∑Œ∫ŒµœçœÑŒ∑Œ∫Œµ œÑŒø ŒµŒ≤Œ¥ŒøŒºŒ±Œ¥ŒπŒ±ŒØŒø œÄœÅœåŒ≥œÅŒ±ŒºŒºŒ±.")
                    else:
                        st.info("Œó Œ±œÄŒøŒ∏ŒÆŒ∫ŒµœÖœÉŒ∑ ŒµŒ≤Œ¥ŒøŒºŒ¨Œ¥Œ±œÇ Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒ∑ (ŒªŒµŒØœÄŒµŒπ bulk_save_week_schedule).")
                st.rerun()
    with colB:
        if st.button("üîÑ Œ¶œåœÅœÑœâœÉŒ∑ Œ±œÄœå ŒíŒî"):
            st.cache_data.clear()
            st.rerun()

# ======================== Tab: Swaps ========================
def _tab_swaps(company: Dict[str, Any], emps: List[Dict[str, Any]]):
    def _has_sig(fn, min_params):
        try:
            return callable(fn) and len(inspect.signature(fn).parameters) >= min_params
        except Exception:
            return False

    SWAPS_OK = (
        _has_sig(create_swap_request, 5) and
        _has_sig(list_swap_requests, 1) and
        _has_sig(update_swap_status, 2) and
        _has_sig(apply_approved_swap, 5) and
        _has_sig(get_schedule_range, 3) and
        _has_sig(get_employee_id_by_name, 2)
    )
    if not SWAPS_OK:
        st.info("Œó ŒµŒΩœåœÑŒ∑œÑŒ± ŒµŒØŒΩŒ±Œπ Œ±œÄŒµŒΩŒµœÅŒ≥ŒøœÄŒøŒπŒ∑ŒºŒ≠ŒΩŒ∑: œÑŒ± DB helpers Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ œÄŒªŒÆœÅœâœÇ œÉœÖŒºŒ≤Œ±œÑŒ¨.")
        return

    with st.expander("üìù Œ•œÄŒøŒ≤ŒøŒªŒÆ Œ±ŒπœÑŒÆŒºŒ±œÑŒøœÇ (ŒµœÅŒ≥Œ±Œ∂œåŒºŒµŒΩŒøœÖ)", expanded=False):
        st.caption("ŒëŒΩœÑŒ±ŒªŒªŒ±Œ≥ŒÆ Œ≥ŒπŒ± **œÑŒø ŒØŒ¥ŒπŒø ŒµŒØŒ¥ŒøœÇ Œ≤Œ¨œÅŒ¥ŒπŒ±œÇ** œÑŒ∑ŒΩ ŒØŒ¥ŒπŒ± Œ∑ŒºŒ≠œÅŒ±.")
        emp_names = [e["name"] for e in emps]
        req_emp = st.selectbox("ŒëŒπœÑœéŒΩ", emp_names, key="swap_req_emp")
        target_emp = st.selectbox("Œ£œÖŒΩŒ¨Œ¥ŒµŒªœÜŒøœÇ", [n for n in emp_names if n != req_emp], key="swap_target_emp")
        req_date = st.date_input("ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±", dt_date.today(), key="swap_date")
        req_shift = st.selectbox("ŒíŒ¨œÅŒ¥ŒπŒ±", company.get("active_shifts", []), key="swap_shift")

        if st.button("üì® Œ•œÄŒøŒ≤ŒøŒªŒÆ Œ±ŒπœÑŒÆŒºŒ±œÑŒøœÇ"):
            rid = get_employee_id_by_name(company["id"], req_emp)
            tid = get_employee_id_by_name(company["id"], target_emp)
            have = get_schedule_range(company["id"], req_date.isoformat(), req_date.isoformat())
            target_has = any(x.get("employee_id") == tid and x.get("shift") == req_shift for x in (have or []))
            requester_has = any(x.get("employee_id") == rid and x.get("shift") == req_shift for x in (have or []))
            if not requester_has:
                st.error("Œü Œ±ŒπœÑœéŒΩ Œ¥ŒµŒΩ Œ≠œáŒµŒπ Œ±œÖœÑŒÆ œÑŒ∑ Œ≤Œ¨œÅŒ¥ŒπŒ±.")
            elif not target_has:
                st.error("Œü œÉœÖŒΩŒ¨Œ¥ŒµŒªœÜŒøœÇ Œ¥ŒµŒΩ Œ≠œáŒµŒπ Œ±œÖœÑŒÆ œÑŒ∑ Œ≤Œ¨œÅŒ¥ŒπŒ±.")
            else:
                create_swap_request(company["id"], rid, tid, req_date.isoformat(), req_shift)
                st.success("ŒöŒ±œÑŒ±œáœâœÅŒÆŒ∏Œ∑Œ∫Œµ Œ±ŒØœÑŒ∑ŒºŒ± (pending).")

    with st.expander("üìã ŒïŒ∫Œ∫œÅŒµŒºŒÆ Œ±ŒπœÑŒÆŒºŒ±œÑŒ± (manager)", expanded=True):
        pending = list_swap_requests(company["id"], status="pending")
        if not pending:
            st.info("ŒöŒ±ŒºŒØŒ± ŒµŒ∫Œ∫œÅŒµŒºœåœÑŒ∑œÑŒ±.")
        else:
            for r in pending:
                st.markdown(f"- **#{r['id']}** {r['date']} ‚Ä¢ *{r['shift']}* ‚Äî {r['requester_name']} ‚Üí {r['target_name']}")
                c1, c2, c3 = st.columns([0.2, 0.2, 0.6])
                note = c3.text_input("Œ£Œ∑ŒºŒµŒØœâœÉŒ∑", key=f"note_{r['id']}")
                if c1.button("‚úÖ ŒàŒ≥Œ∫œÅŒπœÉŒ∑", key=f"ok_{r['id']}"):
                    day_sched = get_schedule_range(company["id"], r["date"], r["date"])
                    req_has = any(x.get("employee_id") == r["requester_id"] and x.get("shift") == r["shift"] for x in (day_sched or []))
                    target_has = any(x.get("employee_id") == r["target_employee_id"] and x.get("shift") == r["shift"] for x in (day_sched or []))
                    if not (req_has and target_has):
                        st.error("Œ§Œø Œ∂ŒµœçŒ≥ŒøœÇ Œ≤Œ±œÅŒ¥ŒπœéŒΩ Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ Œ≠Œ≥Œ∫œÖœÅŒø œÄŒªŒ≠ŒøŒΩ.")
                    else:
                        update_swap_status(r["id"], "approved", note)
                        apply_approved_swap(company["id"], r["date"], r["shift"], r["requester_id"], r["target_employee_id"])
                        st.success("ŒïœÜŒ±œÅŒºœåœÉœÑŒ∑Œ∫Œµ.")
                        st.rerun()
                if c2.button("‚õîÔ∏è ŒëœÄœåœÅœÅŒπœàŒ∑", key=f"reject_{r['id']}"):
                    update_swap_status(r["id"], "rejected", note)
                    st.info("ŒëœÄŒøœÅœÅŒØœÜŒ∏Œ∑Œ∫Œµ.")
                    st.rerun()

# ------------------------- Handlers ------------------------- #
def _add_employee_handler(company, name, roles, availability):
    errors = []
    if not name.strip():
        errors.append("Œ§Œø œåŒΩŒøŒºŒ± ŒµŒØŒΩŒ±Œπ œÖœÄŒøœáœÅŒµœâœÑŒπŒ∫œå.")
    if any(r not in company.get("roles", []) for r in roles):
        errors.append("ŒúŒ∑ Œ≠Œ≥Œ∫œÖœÅŒøœÇ œÅœåŒªŒøœÇ.")
    if any(s not in company.get("active_shifts", []) for s in availability):
        errors.append("ŒúŒ∑ Œ≠Œ≥Œ∫œÖœÅŒ∑ Œ≤Œ¨œÅŒ¥ŒπŒ± Œ¥ŒπŒ±Œ∏ŒµœÉŒπŒºœåœÑŒ∑œÑŒ±œÇ.")
    if errors:
        for e in errors: st.error(e)
        return

    fresh = get_company(company.get("id")) if callable(get_company) else company
    if not fresh:
        st.error("Œó ŒµœÄŒπœáŒµŒØœÅŒ∑œÉŒ∑ Œ¥ŒµŒΩ œÖœÄŒ¨œÅœáŒµŒπ œÄŒªŒ≠ŒøŒΩ.")
        st.session_state.pop("company", None)
        st.rerun()
    if fresh.get("id", 0) < 0:
        st.info("Demo ŒµœÑŒ±ŒπœÅŒµŒØŒ±: Œ∑ œÄœÅŒøœÉŒ∏ŒÆŒ∫Œ∑ œÖœÄŒ±ŒªŒªŒÆŒªŒøœÖ Œ¥ŒµŒΩ Œ±œÄŒøŒ∏Œ∑Œ∫ŒµœçŒµœÑŒ±Œπ œÉœÑŒ∑ ŒíŒî.")
        st.stop()

    try:
        if callable(add_employee):
            add_employee(fresh["id"], name.strip(), roles, availability)
            st.session_state.employees = _cached_employees.clear() or _cached_employees(fresh["id"])
            st.success(f"Œ†œÅŒøœÉœÑŒ≠Œ∏Œ∑Œ∫Œµ Œø/Œ∑ {name.strip()}")
            st.rerun()
        else:
            st.info("ŒõŒµŒπœÑŒøœÖœÅŒ≥ŒØŒ± ŒµœÄŒØŒ¥ŒµŒπŒæŒ∑œÇ: Œ∑ ŒíŒî Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒ∑.")
    except Exception as ex:
        st.error(f"ŒëœÄŒøœÑœÖœáŒØŒ± œÄœÅŒøœÉŒ∏ŒÆŒ∫Œ∑œÇ: {ex}")

def _save_employee_handler(emp, new_name, new_roles, new_av, role_options, shift_options):
    if any(r not in role_options for r in new_roles):
        st.error("ŒúŒ∑ Œ≠Œ≥Œ∫œÖœÅŒøœÇ œÅœåŒªŒøœÇ.")
        return
    if any(s not in shift_options for s in new_av):
        st.error("ŒúŒ∑ Œ≠Œ≥Œ∫œÖœÅŒ∑ Œ≤Œ¨œÅŒ¥ŒπŒ± Œ¥ŒπŒ±Œ∏ŒµœÉŒπŒºœåœÑŒ∑œÑŒ±œÇ.")
        return
    try:
        if callable(update_employee) and callable(get_employees):
            update_employee(emp["id"], new_name.strip(), new_roles, new_av)
            st.session_state.employees = _cached_employees.clear() or _cached_employees(st.session_state.company["id"])
            st.success("ŒëœÄŒøŒ∏Œ∑Œ∫ŒµœçœÑŒ∑Œ∫Œµ.")
            st.rerun()
        else:
            st.info("ŒõŒµŒπœÑŒøœÖœÅŒ≥ŒØŒ± ŒµœÄŒØŒ¥ŒµŒπŒæŒ∑œÇ: Œ∑ ŒíŒî Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒ∑.")
    except Exception as ex:
        st.error(f"ŒëœÄŒøœÑœÖœáŒØŒ± Œ±œÄŒøŒ∏ŒÆŒ∫ŒµœÖœÉŒ∑œÇ: {ex}")

def _delete_employee_handler(emp):
    try:
        if callable(delete_employee) and callable(get_employees):
            delete_employee(emp["id"])
            st.session_state[f"confirm_del_{emp['id']}"] = False
            st.session_state.employees = _cached_employees.clear() or _cached_employees(st.session_state.company["id"])
            st.success("ŒîŒπŒ±Œ≥œÅŒ¨œÜŒ∑Œ∫Œµ.")
            st.rerun()
        else:
            st.info("ŒõŒµŒπœÑŒøœÖœÅŒ≥ŒØŒ± ŒµœÄŒØŒ¥ŒµŒπŒæŒ∑œÇ: Œ∑ ŒíŒî Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒ∑.")
    except Exception as ex:
        st.error(f"ŒëœÄŒøœÑœÖœáŒØŒ± Œ¥ŒπŒ±Œ≥œÅŒ±œÜŒÆœÇ: {ex}")

# ------------------------- Core Scheduling Helpers ------------------------- #
def _sanitize_default(options: List[str], default_vals: List[str]) -> Tuple[List[str], List[str]]:
    opts = set(options or [])
    default_vals = default_vals or []
    valid = [v for v in default_vals if v in opts]
    missing = [v for v in default_vals if v not in opts]
    return valid, missing

def _shift_len(shift: str) -> int:
    s, e = SHIFT_TIMES.get(shift, (9, 17))
    return (24 - s + e) if e < s else (e - s)

def _ensure_schedule_df(df: Optional[pd.DataFrame]) -> pd.DataFrame:
    cols = ["ŒóŒºŒ≠œÅŒ±", "ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±", "ŒíŒ¨œÅŒ¥ŒπŒ±", "Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ", "Œ°œåŒªŒøœÇ", "ŒèœÅŒµœÇ"]
    if df is None or df.empty:
        out = pd.DataFrame(columns=cols)
        out["ŒèœÅŒµœÇ"] = pd.Series([], dtype="float64")
        return out
    for c in cols:
        if c not in df.columns:
            df[c] = 0 if c == "ŒèœÅŒµœÇ" else ""
    out = df[cols].copy()
    out["ŒèœÅŒµœÇ"] = pd.to_numeric(out["ŒèœÅŒµœÇ"], errors="coerce").fillna(0).astype(float)
    return out

def _availability_list(emp: Dict[str, Any]) -> List[str]:
    av = emp.get("availability", [])
    if isinstance(av, dict):
        return [k for k, v in av.items() if v]
    if isinstance(av, list):
        return av
    return []

def _employee_roles(emp: Dict[str, Any]) -> List[str]:
    roles = emp.get("roles", [])
    if isinstance(roles, list):
        return roles
    if isinstance(roles, str) and roles.strip():
        return [roles.strip()]
    return []

def generate_schedule(start_date, employees, active_shifts, roles, rules, role_settings, days_count):
    if not employees:
        empty = _ensure_schedule_df(pd.DataFrame())
        return empty, pd.DataFrame(columns=["ŒóŒºŒ≠œÅŒ±", "ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±", "ŒíŒ¨œÅŒ¥ŒπŒ±", "Œ°œåŒªŒøœÇ", "ŒõŒµŒØœÄŒøœÖŒΩ"])

    start_date = pd.to_datetime(start_date).date()
    rows, missing = [], []
    min_per = {r: max(0, int(role_settings.get(r, {}).get("min_per_shift", 1))) for r in roles}

    idx = 0
    order = list(employees)

    for d in range(days_count):
        day_dt = start_date + dt.timedelta(days=d)
        weekday_name = DAYS[day_dt.weekday()]
        for shift in active_shifts:
            need = dict(min_per)
            for _ in range(len(order)):
                emp = order[idx % len(order)]
                idx += 1
                avail_list = _availability_list(emp)
                if shift not in avail_list:
                    continue
                eroles = _employee_roles(emp)
                if not eroles:
                    continue

                placed = False
                for r in sorted(eroles, key=lambda x: role_settings.get(x, {}).get("priority", 5)):
                    if r not in roles:
                        continue
                    if need.get(r, 0) > 0:
                        rows.append({
                            "ŒóŒºŒ≠œÅŒ±": weekday_name,
                            "ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±": str(day_dt),
                            "ŒíŒ¨œÅŒ¥ŒπŒ±": shift,
                            "Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ": emp.get("name", ""),
                            "Œ°œåŒªŒøœÇ": r,
                            "ŒèœÅŒµœÇ": float(_shift_len(shift)),
                        })
                        need[r] -= 1
                        placed = True
                        break
                if placed and all(v == 0 for v in need.values()):
                    break

            for r_name, left in need.items():
                if left > 0:
                    missing.append({
                        "ŒóŒºŒ≠œÅŒ±": weekday_name,
                        "ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±": str(day_dt),
                        "ŒíŒ¨œÅŒ¥ŒπŒ±": shift,
                        "Œ°œåŒªŒøœÇ": r_name,
                        "ŒõŒµŒØœÄŒøœÖŒΩ": left,
                    })

    df = pd.DataFrame(rows, columns=["ŒóŒºŒ≠œÅŒ±", "ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±", "ŒíŒ¨œÅŒ¥ŒπŒ±", "Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ", "Œ°œåŒªŒøœÇ", "ŒèœÅŒµœÇ"])
    missing_df = pd.DataFrame(missing, columns=["ŒóŒºŒ≠œÅŒ±", "ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±", "ŒíŒ¨œÅŒ¥ŒπŒ±", "Œ°œåŒªŒøœÇ", "ŒõŒµŒØœÄŒøœÖŒΩ"])
    return _ensure_schedule_df(df), missing_df

def _empty_state(header: str, lines: List[str], demo_button: bool = False, on_demo=None):
    st.subheader(header)
    for line in lines:
        st.caption(line)
    if demo_button and on_demo:
        if st.button("‚ú® Œ£œÖŒºœÄŒªŒÆœÅœâœÉŒ∑ demo Œ¥ŒµŒ¥ŒøŒºŒ≠ŒΩœâŒΩ", type="secondary"):
            on_demo()
            st.toast("ŒîŒ∑ŒºŒπŒøœÖœÅŒ≥ŒÆŒ∏Œ∑Œ∫Œ±ŒΩ demo Œ¥ŒµŒ¥ŒøŒºŒ≠ŒΩŒ±", icon="‚ú®")
            st.rerun()

def back_to_company_selection(key: str):
    if st.button("‚¨ÖÔ∏è ŒïœÄŒπœÉœÑœÅŒøœÜŒÆ œÉœÑŒ∑ŒΩ ŒïœÄŒπŒªŒøŒ≥ŒÆ ŒïœÄŒπœáŒµŒØœÅŒ∑œÉŒ∑œÇ", key=key):
        for k in ("company", "employees", "schedule", "missing_staff"):
            st.session_state.pop(k, None)
        st.rerun()

def _demo_seed():
    st.session_state.company = {
        "id": -1,
        "name": "Demo Coffee",
        "work_model": "5ŒÆŒºŒµœÅŒø",
        "rules": {
            "max_daily_hours_5days": 8,
            "weekly_hours_5days": 40,
            "min_daily_rest": 11,
            "max_consecutive_days": 6
        },
        "roles": ["Barista", "Cashier"],
        "active_shifts": ["Œ†œÅœâŒØ", "ŒëœÄœåŒ≥ŒµœÖŒºŒ±"],
        "role_settings": {
            "Barista": {"priority": 3, "min_per_shift": 1, "preferred_shifts": ["Œ†œÅœâŒØ"]},
            "Cashier": {"priority": 5, "min_per_shift": 1, "preferred_shifts": ["ŒëœÄœåŒ≥ŒµœÖŒºŒ±"]},
        }
    }
    st.session_state.employees = [
        {"id": 1, "name": "Maria Papadopoulou", "roles": ["Barista"], "availability": ["Œ†œÅœâŒØ", "ŒëœÄœåŒ≥ŒµœÖŒºŒ±"]},
        {"id": 2, "name": "Nikos Georgiou", "roles": ["Cashier"], "availability": ["ŒëœÄœåŒ≥ŒµœÖŒºŒ±"]},
        {"id": 3, "name": "Eleni Kostopoulou", "roles": ["Barista", "Cashier"], "availability": ["Œ†œÅœâŒØ", "ŒëœÄœåŒ≥ŒµœÖŒºŒ±"]},
    ]
    today = dt.date.today()
    rows = []
    for i in range(7):
        d = today + dt.timedelta(days=i)
        rows.append({"ŒóŒºŒ≠œÅŒ±": DAYS[d.weekday()], "ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±": str(d), "ŒíŒ¨œÅŒ¥ŒπŒ±": "Œ†œÅœâŒØ", "Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ": "Maria Papadopoulou", "Œ°œåŒªŒøœÇ": "Barista", "ŒèœÅŒµœÇ": 8.0})
        rows.append({"ŒóŒºŒ≠œÅŒ±": DAYS[d.weekday()], "ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±": str(d), "ŒíŒ¨œÅŒ¥ŒπŒ±": "ŒëœÄœåŒ≥ŒµœÖŒºŒ±", "Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ": "Nikos Georgiou", "Œ°œåŒªŒøœÇ": "Cashier", "ŒèœÅŒµœÇ": 7.0})
    st.session_state.schedule = pd.DataFrame(rows)
    st.session_state.missing_staff = pd.DataFrame()

# ------------------------- Grid / IO helpers ------------------------- #
def _week_dates(start_date: dt.date, days: int = 7) -> List[dt.date]:
    return [start_date + dt.timedelta(days=i) for i in range(days)]

def _column_key(date: dt.date, shift: str) -> str:
    return f"{date.isoformat()}__{shift}"

def _parse_column_key(k: str) -> Tuple[dt.date, str]:
    d, s = k.split("__", 1)
    return dt.date.fromisoformat(d), s

def _overlap(a_shift: str, b_shift: str) -> bool:
    sa, ea = SHIFT_TIMES.get(a_shift, (9, 17))
    sb, eb = SHIFT_TIMES.get(b_shift, (9, 17))
    def _range(s, e):
        if e < s:  # wrap at midnight
            return [(s, 24), (24, 24 + e)]
        return [(s, e)]
    ra, rb = _range(sa, ea), _range(sb, eb)
    for a1, a2 in ra:
        for b1, b2 in rb:
            if max(a1, b1) < min(a2, b2):
                return True
    return False

def _validate_no_double_bookings(grid_df: pd.DataFrame) -> List[str]:
    errors = []
    for _, row in grid_df.iterrows():
        name = row["Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ"]
        per_day: Dict[dt.date, List[str]] = {}
        for col, val in row.items():
            if col == "Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ" or not val or val == "‚Äî (Œ∫Œ±ŒºŒØŒ±)":
                continue
            d, s = _parse_column_key(col)
            per_day.setdefault(d, []).append(s)
        for day, shifts in per_day.items():
            for i in range(len(shifts)):
                for j in range(i + 1, len(shifts)):
                    if _overlap(shifts[i], shifts[j]):
                        errors.append(f"ŒîŒπœÄŒªŒøŒ∫œÅŒ¨œÑŒ∑œÉŒ∑: {name} œÑŒ∑ŒΩ {day} ({shifts[i]} ‚Üî {shifts[j]})")
    return errors

def _grid_from_db_week(company_id: int, employees: List[Dict[str, Any]], start_date: dt.date) -> pd.DataFrame:
    dates = _week_dates(start_date)
    active_shifts = st.session_state.company.get("active_shifts", [])
    cols = ["Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ"] + [_column_key(d, s) for d in dates for s in active_shifts]
    df = pd.DataFrame(columns=cols)
    df["Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ"] = [e["name"] for e in employees]
    for c in cols:
        if c != "Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ":
            df[c] = "‚Äî (Œ∫Œ±ŒºŒØŒ±)"

    if callable(get_schedule_range):
        try:
            existing = _cached_schedule(company_id, dates[0].isoformat(), dates[-1].isoformat())
            for row in existing or []:
                key = _column_key(dt.date.fromisoformat(row["date"]), row["shift"])
                value = row.get("role") if row.get("role") else "‚Äî (œáœâœÅŒØœÇ œÅœåŒªŒø)"
                if key in df.columns:
                    df.loc[df["Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ"] == row.get("employee_name", ""), key] = value
        except Exception:
            st.info("‚ö†Ô∏è ŒëŒ¥œÖŒΩŒ±ŒºŒØŒ± œÜœåœÅœÑœâœÉŒ∑œÇ ŒµŒ≤Œ¥ŒøŒºŒ¨Œ¥Œ±œÇ Œ±œÄœå ŒíŒî (Œ≠ŒªŒµŒ≥œáŒøœÇ œÉœÖŒºŒ≤Œ±œÑœåœÑŒ∑œÑŒ±œÇ).")
    else:
        st.info("Œó œÜœåœÅœÑœâœÉŒ∑ ŒµŒ≤Œ¥ŒøŒºŒ¨Œ¥Œ±œÇ Œ±œÄœå œÑŒ∑ ŒíŒî Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒ∑ (ŒªŒµŒØœÄŒµŒπ get_schedule_range).")
    return df

def _assignments_from_grid(grid_df: pd.DataFrame, employees: List[Dict[str, Any]], start_date: dt.date) -> List[Dict[str, Any]]:
    name_to_id = {e["name"]: e["id"] for e in employees}
    valid_roles = set(st.session_state.company.get("roles", []))
    assignments: List[Dict[str, Any]] = []
    for _, row in grid_df.iterrows():
        emp_name = row["Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ"]
        emp_id = name_to_id.get(emp_name)
        if not emp_id:
            continue
        for col, val in row.items():
            if col == "Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ" or not val or val == "‚Äî (Œ∫Œ±ŒºŒØŒ±)":
                continue
            d, s = _parse_column_key(col)
            if val == "‚Äî (œáœâœÅŒØœÇ œÅœåŒªŒø)":
                assignments.append({"employee_id": emp_id, "date": d.isoformat(), "shift": s, "role": None})
            elif val in valid_roles:
                assignments.append({"employee_id": emp_id, "date": d.isoformat(), "shift": s, "role": val})
            else:
                assignments.append({"employee_id": emp_id, "date": d.isoformat(), "shift": s, "role": None})
    return assignments

# ======================== Generate helpers ========================
def _generate_and_save(company, emps, start_date, days_count):
    df, missing_df = generate_schedule(
        start_date,
        emps,
        company.get("active_shifts", []),
        company.get("roles", []),
        company.get("rules", {}),
        company.get("role_settings", {}),
        days_count,
    )
    if callable(_auto_fix_schedule):
        fixed_df, viols = _auto_fix_schedule(
            df, emps,
            company.get("active_shifts", []),
            company.get("roles", []),
            company.get("rules", {}),
            company.get("role_settings", {}),
            company.get("work_model", "5ŒÆŒºŒµœÅŒø"),
        )
    else:
        _df_for_validation = df.copy()
        if "ŒèœÅŒµœÇ" in _df_for_validation.columns:
            _df_for_validation["ŒèœÅŒµœÇ"] = pd.to_numeric(_df_for_validation["ŒèœÅŒµœÇ"], errors="coerce").fillna(0).astype(int)
        viols = check_violations(_df_for_validation, company.get("rules", {}), company.get("work_model", "5ŒÆŒºŒµœÅŒø"))
        fixed_df = df

    st.session_state.schedule = fixed_df
    st.session_state.missing_staff = missing_df
    st.session_state.violations = viols

    assignments: List[Dict[str, Any]] = []
    period_start = start_date
    period_end = start_date + timedelta(days=days_count - 1)

    def _name_to_id(nm: str):
        if callable(get_employee_id_by_name):
            return get_employee_id_by_name(company["id"], nm)
        return None

    for _, r in fixed_df.iterrows():
        d = pd.to_datetime(r["ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±"]).date()
        if period_start <= d <= period_end and r.get("ŒíŒ¨œÅŒ¥ŒπŒ±") in company.get("active_shifts", []):
            eid = _name_to_id(r["Œ•œÄŒ¨ŒªŒªŒ∑ŒªŒøœÇ"])
            if eid:
                assignments.append({
                    "employee_id": eid,
                    "date": d.isoformat(),
                    "shift": r["ŒíŒ¨œÅŒ¥ŒπŒ±"],
                    "role": r.get("Œ°œåŒªŒøœÇ") or None,
                })
    if company.get("id", 0) < 0:
        st.info("Demo ŒµœÑŒ±ŒπœÅŒµŒØŒ±: Œ¥Œ∑ŒºŒπŒøœÖœÅŒ≥ŒÆŒ∏Œ∑Œ∫Œµ œÄœÅœåŒ≥œÅŒ±ŒºŒºŒ±, Œ±ŒªŒªŒ¨ Œ∑ Œ±œÄŒøŒ∏ŒÆŒ∫ŒµœÖœÉŒ∑ œÉœÑŒ∑ ŒíŒî ŒµŒØŒΩŒ±Œπ Œ±œÄŒµŒΩŒµœÅŒ≥ŒøœÄŒøŒπŒ∑ŒºŒ≠ŒΩŒ∑.")
    else:
        if callable(bulk_save_week_schedule):
            bulk_save_week_schedule(company["id"], assignments)  # 2‚Äëarg signature
            st.success("ŒîŒ∑ŒºŒπŒøœÖœÅŒ≥ŒÆŒ∏Œ∑Œ∫Œµ Œ∫Œ±Œπ Œ±œÄŒøŒ∏Œ∑Œ∫ŒµœçœÑŒ∑Œ∫Œµ Œ∑ œÄŒµœÅŒØŒøŒ¥ŒøœÇ.")
        else:
            st.info("Œó Œ±œÄŒøŒ∏ŒÆŒ∫ŒµœÖœÉŒ∑ Œ¥ŒµŒΩ ŒµŒØŒΩŒ±Œπ Œ¥ŒπŒ±Œ∏Œ≠œÉŒπŒºŒ∑ (ŒªŒµŒØœÄŒµŒπ bulk_save_week_schedule).")
    st.rerun()

def _refix_current(company, emps):
    if callable(_auto_fix_schedule):
        fixed_df, viols = _auto_fix_schedule(
            st.session_state.schedule, emps,
            company.get("active_shifts", []),
            company.get("roles", []),
            company.get("rules", {}),
            company.get("role_settings", {}),
            company.get("work_model", "5ŒÆŒºŒµœÅŒø"),
        )
    else:
        _df_for_validation = st.session_state.schedule.copy()
        if "ŒèœÅŒµœÇ" in _df_for_validation.columns:
            _df_for_validation["ŒèœÅŒµœÇ"] = pd.to_numeric(_df_for_validation["ŒèœÅŒµœÇ"], errors="coerce").fillna(0).astype(int)
        fixed_df = st.session_state.schedule
        viols = check_violations(_df_for_validation, company.get("rules", {}), company.get("work_model", "5ŒÆŒºŒµœÅŒø"))
    st.session_state.schedule = fixed_df
    st.session_state.violations = viols
    st.success("ŒüŒªŒøŒ∫ŒªŒ∑œÅœéŒ∏Œ∑Œ∫Œµ Œø ŒµœÄŒ±ŒΩŒ≠ŒªŒµŒ≥œáŒøœÇ.")
    st.rerun()
